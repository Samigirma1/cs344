Exercise 3.1
Pull sudoku.py and try running each of the algorithms on each of the predefined sudoku puzzles. Consider the following
questions:

a. Which algorithms work (in a timely manner) and which donâ€™t? Explain your results in terms of the capabilities (and
   implementations) of the algorithms and nature of the problems.

    ANSWER:

    easy_fig64a:
        DFS - Does not solve the problem. DFS is a classical search algorithm that only looks for the possible goal
            state. So, for a search space this big is highly unlikely for it find a solution.

        AC-3 - Solves the problem quickly. The algorithm looks ar values in a cells the current box, and its row and
            column to eliminate values that violate sudoku's constraints. For an easy puzzle, reduce the domain of each
            cell to a single value so that we can quickly get to a solution.

        Backtracking search - takes a while to solve the problem. This is because backtracking search is essentially a
            DFS that steps back when it finds an inconsistent node instead of recursively searching for goal board that
            satisfies the constraints.

        Minimum Conflicts - does not solve the problem.

    harder_aima_csp: Non of the algorithms solved the problem in time
        DFS - similar reason to easy_fig64a.

        AC-3 - It is a greedy algorithm. So, when it removes values from a variable's domain, it may have removed values
            needed for the solution.

        Backtracking search - The problem has more variables compared to easy_fig64a. So, the search tree has even g

        Minimum Conflicts - does not solve the problem.


b. What effect does configuring the settings for backtracking have on the results? Try the following:
    i. Set the variable/value ordering (i.e., the select_unassigned_variable parameter) to first-unassigned-variable
    (the default) or minimum-remaining-values (i.e., mrv).

        ANSWER:

    ii. Set the inference (i.e., the inference parameter) to forward-checking (i.e., forward_checking).

        ANSWER:

    Which, if any, of these settings should work best for sudoku? What combination of settings actually works the best?

        ANSWER:

Exercise 3.2
Pull queens.py and try running each of the algorithms with various values for n. Answer the following questions:

a. How large can n get for each of the algorithms? Why?

    ANSWER:

b. What backtracking settings work the best? Why?

    ANSWER:

c. How many steps does Min-Conflicts require to do its work? Why?

    ANSWER:

Exercise 3.3
Review the AIMA Python implementation for constraint satisfaction problems (CSP) as needed to do the following:

a. Compare and contrast the specifications for CSP (i.e., csp.CSP) and traditional problems (i.e., search.Problem). Be sure
   to consider the nature of states, domains, actions, results and goal tests.

   ANSWER:

b. Compare and contrast the nature of the heuristics deployed in traditional and constraint-based problem solving.

   ANSWER: