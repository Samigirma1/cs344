Exercise 3.1
Pull sudoku.py and try running each of the algorithms on each of the predefined sudoku puzzles. Consider the following
questions:

a. Which algorithms work (in a timely manner) and which donâ€™t? Explain your results in terms of the capabilities (and
   implementations) of the algorithms and nature of the problems.

    ANSWER:
        DFS -
            easy_fig64a: not solved
            harder_aima_csp: Not solved
            hardest_escargot: not solved

            Explanation:
                DFS is a classical search algorithm that only looks for the possible goal state by populating the table
                unit-by-unit and checking if the populated board is a goal board. So, for a search space this big is
                highly unlikely for it find a solution for any of the problems in reasonable time.

        AC-3 -
            easy_fig64a: solved quickly
            harder_aima_csp: Not solved
            hardest_escargot: not solved

            Explanation:
                The algorithm looks ar values in a cells the current box, and its row and column to eliminate values
                that violate sudoku's constraints. For an easy puzzle (like easy_fig64a), it can reduce the domain of
                each unit to single values to quickly get to a solution. For harder problems (like harder_aima_csp and
                hardest_escargot), AC-3, trying to meet local constraints, could eliminate values important for the
                final solution(s).

        Backtracking search -

            easy_fig64a: Takes a while but reaches a solution.
            harder_aima_csp: Not solved
            hardest_escargot: not solved

            Explanation:
                This is because backtracking search is essentially a DFS that steps back when it finds an inconsistent
                node instead of populating the entire board before checking if there's something wrong. So, for an easy
                problems with obvious conflicts, backtracking search can find a solution. However, for harder problems,
                it may be take a while for it to find conflicts early and it performance would be much worse.

        Minimum Conflicts -

            easy_fig64a: not solved
            harder_aima_csp: Not solved
            hardest_escargot: not solved

            Explanation:
                It does not solve the problem. The algorithm starts with a complete assignment and tweaks
                adjusts the values of variables in a way that minimizes conflicts, with the hope of eventually finding a
                solution with no conflicts. It resembles the hill-climbing solution and it may be "stuck" at a local
                minimum without reaching a solution.

b. What effect does configuring the settings for backtracking have on the results? Try the following:
    i. Set the variable/value ordering (i.e., the select_unassigned_variable parameter) to first-unassigned-variable
    (the default) or minimum-remaining-values (i.e., mrv).

        ANSWER:
        In theory, it should improve its performance by significantly by choosing the variable that has the least number
        of values in its domain. By choosing the most constraining variable early, it should reduce the find conflicts
        sooner without having to go much deeper in the search tree. But, it did not make much of a difference in this
        problem.

    ii. Set the inference (i.e., the inference parameter) to forward-checking (i.e., forward_checking).

        ANSWER:
        It improved the algorithms performance significantly. It even solves hard_aima_csp in less than a minute. Making
        constrained nodes consistent whenever a value is assigned would reduce the size of the search tree frequently.

    Which, if any, of these settings should work best for sudoku? What combination of settings actually works the best?

        ANSWER:
        Forward-checking improves works best for sudoku. It does even better when its combined with
        minimum-remaining-values ordering. It can even solve the hardest problem.

Exercise 3.2
Pull queens.py and try running each of the algorithms with various values for n. Answer the following questions:

a. How large can n get for each of the algorithms? Why?

    ANSWER:

b. What backtracking settings work the best? Why?

    ANSWER:

c. How many steps does Min-Conflicts require to do its work? Why?

    ANSWER:

Exercise 3.3
Review the AIMA Python implementation for constraint satisfaction problems (CSP) as needed to do the following:

a. Compare and contrast the specifications for CSP (i.e., csp.CSP) and traditional problems (i.e., search.Problem). Be sure
   to consider the nature of states, domains, actions, results and goal tests.

   ANSWER:

b. Compare and contrast the nature of the heuristics deployed in traditional and constraint-based problem solving.

   ANSWER: